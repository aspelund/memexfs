# Architecture

## Overview

memexfs is a single Rust binary compiled to WASM. It has three phases:

```
LOAD → INDEX → QUERY
 (once)  (once)  (repeated)
```

After init, the filesystem is entirely in-memory and immutable. All queries are pure lookups with no I/O.

## Data flow

```
┌──────────────────────────────────────────────────┐
│                   MemexFS                         │
│                                                   │
│  ┌─────────┐    ┌──────────┐    ┌─────────────┐  │
│  │  LOAD   │───▶│  INDEX   │───▶│   STORE     │  │
│  │         │    │          │    │             │  │
│  │ Walk dir│    │ Tokenize │    │ Documents   │  │
│  │ Read .md│    │ Inverted │    │ Line-indexed│  │
│  │ Parse   │    │ index    │    │ Path-keyed  │  │
│  └─────────┘    └──────────┘    └─────────────┘  │
│                                   ▲     ▲        │
│                                   │     │        │
│                        ┌──────────┘     │        │
│                        │                │        │
│                   ┌────┴───┐      ┌─────┴────┐   │
│                   │  grep  │      │   read   │   │
│                   └────────┘      └──────────┘   │
│                        │                         │
│                   ┌────┴───┐                     │
│                   │   ls   │                     │
│                   └────────┘                     │
└──────────────────────────────────────────────────┘
```

## In-memory representation

### Document store

Each document is stored as a vector of lines, keyed by its relative path:

```rust
struct DocumentStore {
    docs: HashMap<String, Document>,
}

struct Document {
    path: String,
    lines: Vec<String>,
}
```

This gives us O(1) path lookup and O(1) line-offset access via slice indexing.

### Inverted index

The inverted index maps tokens to the documents and lines they appear in:

```rust
struct InvertedIndex {
    // token → [(doc_path, line_number)]
    index: HashMap<String, Vec<(String, u32)>>,
}
```

Tokens are generated by:

1. Lowercasing the line
2. Splitting on whitespace and punctuation
3. Storing each token with its source location

This supports fast exact-token matching. For regex patterns, we fall back to a linear scan over stored lines — still sub-millisecond at < 500 docs.

## Query execution

### grep(pattern, glob?)

```
1. If pattern is a simple token (no regex metacharacters):
   → Look up token in inverted index → O(1)
   → Filter by glob if provided
   → Return matches

2. If pattern contains regex:
   → Compile regex (cached)
   → Scan all stored lines (or glob-filtered subset)
   → Return matches

3. If glob is provided:
   → Filter document set first, then search within matches only
```

### read(path, offset?, limit?)

```
1. Look up document by path → O(1) HashMap lookup
2. If offset/limit provided:
   → Slice the lines vector → O(1)
3. Return lines joined as string
```

### ls(path)

```
1. Normalize path to a prefix (with trailing /)
2. Iterate all document paths in the store
3. For each path matching the prefix:
   → If next segment contains '/', add directory entry (name + '/')
   → Otherwise, add file entry (name)
4. Deduplicate via BTreeSet → sorted output
```

## WASM compilation

```
Rust source
    │
    ▼
wasm-pack build --target web
    │
    ▼
memexfs.wasm + JS bindings
    │
    ▼
npm package
```

The WASM module is loaded once. The `MemexFS` constructor receives a folder path, but since WASM cannot access the host filesystem directly, initialization works via one of two strategies:

### Strategy A: Pre-bundled (recommended for production)

Documents are serialized to a binary blob at build time and embedded in the WASM module or loaded as a sidecar. Init deserializes the blob into memory.

```js
import { MemexFS } from "memexfs";
import docsBlob from "./docs.memex"; // pre-built blob

const fs = MemexFS.fromBlob(docsBlob);
```

A CLI tool generates the blob:

```bash
npx memexfs pack ./docs -o docs.memex
```

### Strategy B: Runtime loading (recommended for development)

The JS wrapper reads files from disk (Node.js) or fetches them (browser) and passes them into WASM as a serialized structure.

```js
import { MemexFS } from "memexfs";

// JS reads the filesystem, passes content to WASM
const fs = new MemexFS("./docs"); // Node.js: uses fs.readdir + fs.readFile under the hood
```

In this mode, the JS binding handles I/O and the Rust/WASM core handles indexing and querying — a clean separation.

## Performance characteristics

### Memory

| Component | Size estimate (500 docs, ~20KB avg) |
|-----------|-------------------------------------|
| Raw document text | ~10 MB |
| Line-indexed storage | ~12 MB (lines + overhead) |
| Inverted index | ~20-30 MB (tokens + locations) |
| **Total** | **~40-50 MB** |

### Time complexity

| Operation | Simple token | Regex | With glob filter |
|-----------|-------------|-------|------------------|
| grep | O(1) lookup + O(k) results | O(n) scan over lines | O(m) where m < n |
| read | O(1) always | — | — |
| ls | O(d) where d = total docs | — | — |

Where:
- k = number of matches for the token
- n = total number of lines across all docs
- m = lines in glob-matched docs only

### What we don't do

- **No stemming or lemmatization.** The LLM handles synonyms. If a user says "cancel" and the doc says "cancellation," the LLM knows to try both.
- **No fuzzy matching.** Regex covers partial matching. The LLM handles the rest.
- **No ranking or scoring.** The LLM reads grep results and decides what's relevant.
- **No caching layer.** Everything is already in memory. There's nothing to cache.
- **No write path.** The filesystem is immutable after init. To update docs, re-init.

## File format support

v1 supports `.md` files only. Each file is:

1. Read as UTF-8 text
2. Split into lines
3. Each line is tokenized for the inverted index
4. The full lines are stored for grep content matching and read output

Images, links, and other markdown elements are stored as-is in the line content. The LLM sees raw markdown including `![alt](url)` image references and renders them as appropriate.
